//*******************************************
// PlyMeshIO.cpp
//
// generated by Chenglei Wu, ORP
//
// copyright reserved
//***************************************

#include "PlyMeshIO.h"

#include <string.h>
#include <stack>
#include <queue>

#ifdef WIN32
#include <conio.h>
#endif



#include <map>

#ifdef WIN32
# ifndef strncasecmp
#  define strncasecmp _strnicmp
# endif
#endif

#define GET_LINE() if (!fgets(buf, 1024, f)) return false
#define COND_READ(cond, where, len) if ((cond) && !fread((void *)&(where), (len), 1, f)) return false
#define LINE_IS(text) !strncasecmp(buf, text, strlen(text))

#define BIGNUM 1.0e10

#ifndef FLOAT_EPSILON
#define FLOAT_EPSILON 0.000001f
#endif


//#define NO_COMP -1
#define FOR_EACH_ADJACENT_FACE(adjacentfaces,v,f) \
for (size_t f_ind = 0, f = adjacentfaces[v][0]; \
	(f_ind < adjacentfaces[v].size()) && \
	((f = adjacentfaces[v][f_ind]) || 1); \
	f_ind++)

// Figure out whether this machine is little- or big-endian
static bool we_are_little_endian()
{
	char buf[4];
	*(int *)(&buf[0]) = 1;
	return (buf[0] == 1);
}

static unsigned char color2uchar(float p)
{
	return min(max(int(255.0f * p + 0.5f), 0), 255);
}

static bool ply_property(const char *buf, int &len, bool binary)
{
	if (LINE_IS("property char") ||
		LINE_IS("property uchar") ||
		LINE_IS("property int8") ||
		LINE_IS("property uint8")) {
		len += 1;
	}
	else if (LINE_IS("property short") ||
		LINE_IS("property ushort") ||
		LINE_IS("property int16") ||
		LINE_IS("property uint16")) {
		len += (binary ? 2 : 1);
	}
	else if (LINE_IS("property int") ||
		LINE_IS("property uint") ||
		LINE_IS("property float") ||
		LINE_IS("property int32") ||
		LINE_IS("property uint32") ||
		LINE_IS("property float32")) {
		len += (binary ? 4 : 1);
	}
	else if (LINE_IS("property double") ||
		LINE_IS("property float64")) {
		len += (binary ? 8 : 1);
	}
	else {
		fprintf(stderr, "Unsupported vertex property: %s\n", buf);
		return false;
	}
	return true;
}

static inline void swap_unsigned(volatile unsigned &x)
{
	x = (x << 24u) |
		((x << 8u) & 0x00ff0000u) |
		((x >> 8u) & 0x0000ff00u) |
		(x >> 24u);
}

static inline void swap_float(float &x)
{
	swap_unsigned(*(unsigned *)(&x));
}

static inline void swap_int(int &x)
{
	swap_unsigned(*(unsigned *)(&x));
}

static void check_need_swap(const CVec3f &p, bool &need_swap)
{
	float p0 = p[0], p1 = p[1], p2 = p[2];
	if (need_swap) {
		swap_float(p0);
		swap_float(p1);
		swap_float(p2);
	}
	bool makes_sense = (p0 > -BIGNUM && p0 < BIGNUM &&
		p1 > -BIGNUM && p1 < BIGNUM &&
		p2 > -BIGNUM && p2 < BIGNUM);
	if (makes_sense)
		return;

	swap_float(p0);
	swap_float(p1);
	swap_float(p2);

	bool makes_sense_swapped = (p0 > -BIGNUM && p0 < BIGNUM &&
		p1 > -BIGNUM && p1 < BIGNUM &&
		p2 > -BIGNUM && p2 < BIGNUM);
	if (makes_sense_swapped) {
		fprintf(stderr, "Compensating for bogus endianness.\n");
		need_swap = !need_swap;
	}
}

static bool slurp_verts_bin(FILE *f, vector<CVec3f> &vertices, bool need_swap, int nverts)
{
	int first = vertices.size() - nverts + 1;
	COND_READ(true, vertices[first][0], (nverts - 1) * 12);
	if (need_swap) {
		for (int i = first; i < vertices.size(); i++) {
			swap_float(vertices[i][0]);
			swap_float(vertices[i][1]);
			swap_float(vertices[i][2]);
		}
	}
	return true;
}


static void skip_comments(FILE *f)
{
	int c;
	bool in_comment = false;
	while (1) {
		c = fgetc(f);
		if (c == EOF)
			return;
		if (in_comment) {
			if (c == '\n')
				in_comment = false;
		}
		else if (c == '#') {
			in_comment = true;
		}
		else if (!isspace(c)) {
			break;
		}
	}
	ungetc(c, f);
}


// Tesselate an arbitrary n-gon.  Appends triangles to "tris".
static void tess(const vector<CVec3f> &verts, const vector<int> &thisface,
	vector<CVec3i> &tris)
{
	if (thisface.size() < 3)
		return;
	if (thisface.size() == 3) {
		tris.push_back(CVec3i(thisface[0],
			thisface[1],
			thisface[2]));
		return;
	}
	if (thisface.size() == 4) {
		// Triangulate in the direction that
		// gives the shorter diagonal
		const CVec3f &p0 = verts[thisface[0]], &p1 = verts[thisface[1]];
		const CVec3f &p2 = verts[thisface[2]], &p3 = verts[thisface[3]];
		float d02 = (p0, p2).MagnitudeSq();
		float d13 = (p1, p3).MagnitudeSq();
		int i = (d02 < d13) ? 0 : 1;
		tris.push_back(CVec3i(thisface[i],
			thisface[(i + 1) % 4],
			thisface[(i + 2) % 4]));
		tris.push_back(CVec3i(thisface[i],
			thisface[(i + 2) % 4],
			thisface[(i + 3) % 4]));
		return;
	}

	// 5-gon or higher - just tesselate arbitrarily...
	for (int i = 2; i < thisface.size(); i++)
		tris.push_back(CVec3i(thisface[0],
		thisface[i - 1],
		thisface[i]));
}


bool PlyMeshIO::read_verts_bin(FILE *f,  bool &need_swap,
	int nverts, int vert_len, int vert_pos, int vert_norm,
	int vert_color, bool float_color, int vert_conf, int vert_uv)
{
	const int vert_size = 12;
	const int norm_size = 12;
	const int color_size = float_color ? 12 : 3;
	const int conf_size = 4;
	const int uv_size = 8;

	if (nverts <= 0 || vert_len < 12 || vert_pos < 0)
		return false;

	int old_nverts = m_vertices.size();
	int new_nverts = old_nverts + nverts;
	m_vertices.resize(new_nverts);

	bool have_norm = (vert_norm >= 0);
	bool have_color = (vert_color >= 0);
	bool have_conf = (vert_conf >= 0);
	bool have_uv = (vert_uv >= 0);
	if (have_norm)
		m_normals.resize(new_nverts);
	if (have_color)
		m_colors.resize(new_nverts);
	if (have_conf)
		m_confidences.resize(new_nverts);
	if (have_uv)
		m_uvcoord.resize(new_nverts);

	unsigned char *buf = new unsigned char[vert_len];
	COND_READ(true, buf[0], vert_len);

	int i = old_nverts;
	memcpy(&m_vertices[i][0], &buf[vert_pos], vert_size);
	if (have_norm)
		memcpy(&m_normals[i][0], &buf[vert_norm], norm_size);
	if (have_color && float_color)
		memcpy(&m_colors[i][0], &buf[vert_color], color_size);
	if (have_color && !float_color){
		m_colors[i] = CVec3f(buf[vert_color] / 255.0f, buf[vert_color+1] / 255.0f, buf[vert_color+2] / 255.0f);
		//memcpy(&m_colors[i][0], &buf[vert_color], color_size);
	}
	if (have_conf)
		memcpy(&m_confidences[i], &buf[vert_conf], conf_size);
	if (have_uv)
		memcpy(&m_uvcoord[i], &buf[vert_uv], uv_size);


	check_need_swap(m_vertices[i], need_swap);
	if (need_swap) {
		swap_float(m_vertices[i][0]);
		swap_float(m_vertices[i][1]);
		swap_float(m_vertices[i][2]);
		if (have_norm) {
			swap_float(m_normals[i][0]);
			swap_float(m_normals[i][1]);
			swap_float(m_normals[i][2]);
		}
		if (have_color && float_color) {
			swap_float(m_colors[i][0]);
			swap_float(m_colors[i][1]);
			swap_float(m_colors[i][2]);
		}
		if (have_conf)
			swap_float(m_confidences[i]);
		if (have_uv){
			swap_float(m_uvcoord[i][0]);
			swap_float(m_uvcoord[i][1]);
		}
	}

	printf("\n  Reading %d vertices... ", nverts);
	if (vert_len == 12 && sizeof(CVec3f) == 12 && nverts > 1)
		return slurp_verts_bin(f, m_vertices, need_swap, nverts);
	while (++i < new_nverts) {
		COND_READ(true, buf[0], vert_len);
		memcpy(&m_vertices[i][0], &buf[vert_pos], vert_size);
		if (have_norm)
			memcpy(&m_normals[i][0], &buf[vert_norm], norm_size);
		if (have_color && float_color)
			memcpy(&m_colors[i][0], &buf[vert_color], color_size);
		if (have_color && !float_color){
			//	m_colors[i] = Color(&buf[vert_color]);
			//memcpy(&m_colors[i][0], &buf[vert_color], color_size);
			m_colors[i] = CVec3f(buf[vert_color] / 255.0f, buf[vert_color + 1] / 255.0f, buf[vert_color + 2] / 255.0f);
		}
		if (have_conf)
			memcpy(&m_confidences[i], &buf[vert_conf], conf_size);
		if (have_uv)
			memcpy(&m_uvcoord[i], &buf[vert_uv], uv_size);


		if (need_swap) {
			swap_float(m_vertices[i][0]);
			swap_float(m_vertices[i][1]);
			swap_float(m_vertices[i][2]);
			if (have_norm) {
				swap_float(m_normals[i][0]);
				swap_float(m_normals[i][1]);
				swap_float(m_normals[i][2]);
			}
			if (have_color && float_color) {
				swap_float(m_colors[i][0]);
				swap_float(m_colors[i][1]);
				swap_float(m_colors[i][2]);
			}
			if (have_conf)
				swap_float(m_confidences[i]);
			if (have_uv){
				swap_float(m_uvcoord[i][0]);
				swap_float(m_uvcoord[i][1]);
			}
		}
	}

	return true;
}

void PlyMeshIO::smoothNormals(int Iters)
{
	vector<CVec3f> tmpnormals = m_normals;

	if (m_neighbors.empty())
		computeNeighbors();

	for (int t = 0; t < Iters; t++)
	{
		std::cout << t << std::endl;
#pragma omp parallel for
		for (int i = 0; i < m_normals.size(); i++)
		{
			//std::cout << i << " vs " << m_neighbors[i].size() << std::endl;
			CVec3f tmpnor(0, 0, 0);
			for (int j = 0; j < m_neighbors[i].size(); j++)
			{
				tmpnor += m_normals[m_neighbors[i][j]];
			}
			tmpnormals[i] = tmpnor.Unit();

			m_normals = tmpnormals;
		}
	}

}

void PlyMeshIO::computeNormals()
{
	//if (m_normals.size() == m_vertices.size())
	//	return;

	
	int nf = m_faces.size(), nv = m_vertices.size();

	printf("Computing normals... ");
	m_normals.clear();
	m_normals.resize(nv, CVec3f(0, 0, 0));
	m_facenormals.clear();
	m_facenormals.resize(nf, CVec3f(0, 0, 0));

	if (nf != 0) {
		// Find normals of a mesh
#pragma omp parallel for
		for (int i = 0; i < nf; i++) {
			const CVec3f &p0 = m_vertices[m_faces[i][0]];
			const CVec3f &p1 = m_vertices[m_faces[i][1]];
			const CVec3f &p2 = m_vertices[m_faces[i][2]];
			CVec3f a = p0 - p1, b = p1 - p2, c = p2 - p0;
			float l2a = a.MagnitudeSq(), l2b = b.MagnitudeSq(), l2c = c.MagnitudeSq();
			CVec3f facenormal = a.Cross(b);
			CVec3f atmp = a, btmp = b;
			if ( l2a > 0 && l2b > 0)
			{
				atmp = a / sqrt(l2a);
				btmp = b / sqrt(l2b);
			}
			m_facenormals[i] = atmp.Cross(btmp);
			if ((facenormal).MagnitudeSq() > 0)
			{
				// m_normals[m_faces[i][0]] += facenormal * (1.0f / (l2a * l2c));
				// m_normals[m_faces[i][1]] += facenormal * (1.0f / (l2b * l2a));
				// m_normals[m_faces[i][2]] += facenormal * (1.0f / (l2c * l2b));

				CVec3f tmpfacnor = facenormal / (facenormal).Magnitude();
				m_normals[m_faces[i][0]] += tmpfacnor;
				m_normals[m_faces[i][1]] += tmpfacnor;
				m_normals[m_faces[i][2]] += tmpfacnor;
			}
		}
	}
	else 
	{
		std::cout << "Not implemented for non-face meshes!!! Error returned!" << std::endl;
	}

#pragma omp parallel for
	for (int i = 0; i < nv; i++)
	{
		float tmpmag = m_normals[i].Magnitude();
		if (tmpmag > 0)
			m_normals[i] /= tmpmag;
	}

	printf("Done.\n");
}


int PlyMeshIO::obtainMaxNumofNeighbors()
{
	if (m_neighbors.empty())
		computeNeighbors();

	int retnum = 0;
	for (int i = 0; i < m_neighbors.size(); i++)
	{
		int tmpnum = m_neighbors[i].size();
		if (tmpnum > retnum)
			retnum = tmpnum;
	}
	std::cout << "Max num of neighbors is " << retnum << std::endl;

	return retnum;
}

void PlyMeshIO::triangleOrderOpt()
{

}

// Find the direct neighbors of each vertex
void PlyMeshIO::computeNeighbors()
{
	if (!m_neighbors.empty())
		return;
	
	printf("Finding vertex neighbors... ");
	int nv = m_vertices.size(), nf = m_faces.size();

	vector<int> numneighbors(nv,0);
	for (int i = 0; i < nf; i++) {
		numneighbors[m_faces[i][0]]++;
		numneighbors[m_faces[i][1]]++;
		numneighbors[m_faces[i][2]]++;
	}

	m_neighbors.resize(nv);
	for (int i = 0; i < nv; i++)
		m_neighbors[i].reserve(numneighbors[i] + 2); // Slop for boundaries

	for (int i = 0; i < nf; i++) {
		for (int j = 0; j < 3; j++) {
			vector<int> &me = m_neighbors[m_faces[i][j]];
			int n1 = m_faces[i][(j + 1) % 3];
			int n2 = m_faces[i][(j + 2) % 3];
			if (find(me.begin(), me.end(), n1) == me.end())
				me.push_back(n1);
			if (find(me.begin(), me.end(), n2) == me.end())
				me.push_back(n2);
		}
	}

	printf("Done.\n");
}

void PlyMeshIO::reoderNeighors()//re order the neighbors in anti-clock direction
{
	printf("ReOdering Neighbors...");
	if (m_neighbors.empty())
		computeNeighbors();
	if (m_adjacentfaces.empty())
		computeAdjacentfaces();

#pragma omp parallel for
	for (int v = 0; v < m_vertices.size(); v++)
	{
		const vector<int> &adjlist = m_adjacentfaces[v];
		vector<int> &neilist = m_neighbors[v];

		if (adjlist.size() == 0 || neilist.size() == 0 || adjlist.size() != neilist.size())
			continue;

		std::map<int,int> tmpmapping;
		for (int i = 0; i < neilist.size(); i++)
			tmpmapping[neilist[i]] = i;

		vector<int> vectmp_ngh(neilist.size(), -1);

		for (int i = 0; i < adjlist.size(); i++)
		{
			CVec3i tmpface = m_faces[adjlist[i]];

			for (int j = 0; j < 3; j++)
			{
				if (tmpface[j] == v)
				{
					int tmpind0 = tmpface[(j + 1) % 3];
					int tmpind1 = tmpface[(j + 2) % 3];

					if (tmpmapping.find(tmpind0) != tmpmapping.end())
					{
						int tmploc = tmpmapping[tmpind0];
						vectmp_ngh[tmploc] = tmpind1;
					}	
					//if (tmpmapping.find(tmpind1) != tmpmapping.end())
					//{
					//	int tmploc = tmpmapping[tmpind1];
					//	vectmp_ngh[tmploc] = tmpind0;
					//}
				}
			}
		}

		vector<int> vectmp_newlist;
		vectmp_newlist.push_back(neilist[0]);
		while (vectmp_newlist.size() <neilist.size())
		{
			if (tmpmapping.find(vectmp_newlist[vectmp_newlist.size() - 1]) != tmpmapping.end())
			{
				int tmpmap = tmpmapping[vectmp_newlist[vectmp_newlist.size() - 1]];
				int tmpval = vectmp_ngh[tmpmap];
				if (tmpval < 0)
				{
					std::cout << "error found 1" << std::endl;
				}
				else
					vectmp_newlist.push_back(tmpval);
			}
			else
			{
				std::cout << "error found 2" << std::endl;
				break;
			}
		}

		for (int i = 0; i < vectmp_newlist.size(); i++)
			neilist[i] = vectmp_newlist[i];

	}

	m_bNeighborReOdered = true;
	printf("Done!\n");
}

void PlyMeshIO::computeEdgeMappedVertices()
{
	if (!m_bNeighborReOdered)
		reoderNeighors();

	int numvertices = m_vertices.size();

	if (!m_edgemappedvetindices.empty()){
		printf("m_edgemappedvetindices not empty! Not re-compute!\n");
		return;
	}
	else
		m_edgemappedvetindices.resize(numvertices);

	printf("Compute Edge Mapped Vertex Indices ...");

	vector<std::map<int, int> > vec_mapping;

	for (int v = 0; v < numvertices; v++)
	{
		const vector<int> &vectmplist = m_neighbors[v];
		int tmpnum = vectmplist.size();
		std::map<int, int> vectmpmap;
		for (int i = 0; i < tmpnum; i++){
			int tmpind = vectmplist[i];
			vectmpmap[tmpind] = i;
		}
		vec_mapping.push_back(vectmpmap);
	}

#pragma omp parallel for
	for (int v = 0; v < numvertices; v++)
	{
		const vector<int> &vectmplist = m_neighbors[v];
		int tmpnum = vectmplist.size();

		m_edgemappedvetindices[v].resize(tmpnum, -1);
		if (tmpnum != m_adjacentfaces[v].size())
			continue;

		for (int i = 0; i < tmpnum; i++)
		{
			int tmpind = vectmplist[i];
			if (m_neighbors[tmpind].size() != m_adjacentfaces[tmpind].size())
				continue;
			
			int tmpvetind = vectmplist[(i + 1) % tmpnum];
			if (m_neighbors[tmpvetind].size() != m_adjacentfaces[tmpvetind].size())
				continue;

			const std::map<int, int>::iterator &it = vec_mapping[tmpvetind].find(tmpind);
			if (it != vec_mapping[tmpvetind].end())
			{
				int tmploc = it->second;
				int tmpnewnum = m_neighbors[tmpvetind].size();
				int tmpedgevetind = m_neighbors[tmpvetind][(tmploc + 1) % tmpnewnum];
				m_edgemappedvetindices[v][i] = tmpedgevetind;
			}else
			{
				std::cout << "Cannot find edge mapped vertex for vertex " << v << " neighor " << i << std::endl;
			}


			//const std::map<int, int>::iterator &its = vec_mapping[tmpind].find(tmpvetind);
			//if (its != vec_mapping[tmpind].end())
			//{
			//	int tmploc = its->second;
			//	int tmpnewnum = m_neighbors[tmpind].size();
			//	int tmpedgevetind = m_neighbors[tmpind][(tmploc - 1 + tmpnewnum) % tmpnewnum];
			//	//m_edgemappedvetindices[v][i] = tmpedgevetind;
			//	if (tmpedgevetind - m_edgemappedvetindices[v][i] != 0){
			//		std::cout << v << ": " << tmpedgevetind << " vs " << m_edgemappedvetindices[v][i] << std::endl;
			//		getch();
			//	}
			//}else
			//{
			//	std::cout << "Cannot find edge mapped vertex for vertex " << v << " neighor " << i << std::endl;
			//}
		}
	}


	//int debugindex = 389974;
	//for (int v = debugindex; v < (1+debugindex); v++)
	//{
	//	const vector<int> &vectmplist = m_neighbors[v];
	//	int tmpnum = vectmplist.size();

	//	CVec3f tmpvetex = m_vertices[v];
	//	
	//	std::cout << tmpnum << std::endl;

	//	for (int i = 0; i < tmpnum; i++)
	//	{
	//		int tmpind = vectmplist[i];

	//		std::cout << "vertex " << v << ": " << tmpind << std::endl;

	//		int tmpvetind = vectmplist[(i + 1) % tmpnum];

	//		CVec3f tmpnor = (m_vertices[tmpvetind] - m_vertices[v]).Cross(m_vertices[tmpind] - m_vertices[v]);
	//		std::cout << tmpnor.x << " | " << tmpnor.y << " | " << tmpnor.z << std::endl;
	//		std::cout << m_normals[i].x << " | " << m_normals[i].y << " | " << m_normals[i].z << std::endl;
	//		tmpnor = tmpnor.Unit();
	//		float tmpdot = tmpnor * m_normals[i];
	//		std::cout << tmpdot << std::endl;
	//		getch();

	//	}
	//}

	printf("Done!\n");










}

void PlyMeshIO::computeCotangentWeights()
{
	if (m_neighbors.empty())
	{
		computeNeighbors();
		reoderNeighors();
	}

	int numvertices = m_vertices.size();

	m_cotweights.resize(numvertices);
#pragma omp parallel for
	for (int i = 0; i < numvertices; i++)
	{
		const vector<int> &vectmplist = m_neighbors[i];
		const int tmpnum = vectmplist.size();
		vector<float> vectmpval(tmpnum, 0);
		float tmpsum = 0;
		for (int j = 0; j < tmpnum; j++)
		{
			int tmpind = vectmplist[j];

			int tmpvetind = vectmplist[(j - 1 + tmpnum) % tmpnum];		

			CVec3f tmpdir0 = (m_vertices[tmpind] - m_vertices[tmpvetind]).Unit();
			CVec3f tmpdir1 = (m_vertices[i] - m_vertices[tmpvetind]).Unit();
			CVec3f tmpnordir = tmpdir1.Cross(tmpdir0);
			float cotval = 1e7;
			if (tmpnordir.Magnitude()>0)
				cotval = tmpdir0*tmpdir1 / tmpnordir.Magnitude();
			vectmpval[j] += cotval;



			tmpvetind = vectmplist[(j + 1 + tmpnum) % tmpnum];
			tmpdir0 = (m_vertices[tmpind] - m_vertices[tmpvetind]).Unit();			
			tmpdir1 = (m_vertices[i] - m_vertices[tmpvetind]).Unit();
			tmpnordir = tmpdir0.Cross(tmpdir1);
			cotval = 1e7;
			if (tmpnordir.Magnitude()>0)
				cotval = tmpdir0*tmpdir1 / tmpnordir.Magnitude();//note that here assume sin to be always positive, which may not be nessesaryily true			
			vectmpval[j] += cotval;

			tmpsum += vectmpval[j];
		}

		if (tmpsum > 0)
		{
			for (int j = 0; j < tmpnum; j++)
				vectmpval[j] /= tmpsum;
				//vectmpval[j] = 1.0f/tmpnum;
		}

		m_cotweights[i] = vectmpval;
	}

}

double PlyMeshIO::computeLaplacianSum()
{
	double retval = 0;

	int numvertices = m_vertices.size();
	for (int i = 0; i < numvertices; i++)
	{
		const vector<int> &vectmplist = m_neighbors[i];
		int tmpnum = vectmplist.size();
		float tmpcoef = 1.0f / (float)tmpnum;
		CVec3f tmplap = m_vertices[i];
		for (int j = 0; j < tmpnum; j++)
		{
			int tmpind = vectmplist[j];
			tmplap -= m_vertices[tmpind] * tmpcoef;
		}
		retval += tmplap.MagnitudeSq();

	}

	return retval;

}


double PlyMeshIO::computeCotLaplacianSum()
{
	if (m_cotweights.empty())
		computeCotangentWeights();

	double retval = 0;

	int numvertices = m_vertices.size();
	for (int i = 0; i < numvertices; i++)
	{
		const vector<int> &vectmplist = m_neighbors[i];
		const vector<float> &vectmpwts = m_cotweights[i];
		int tmpnum = vectmplist.size();
		//float tmpcoef = 1.0f / (float)tmpnum;
		CVec3f tmplap = m_vertices[i];
		for (int j = 0; j < tmpnum; j++)
		{
			int tmpind = vectmplist[j];
			float tmpcoef = vectmpwts[j];
			tmplap -= m_vertices[tmpind] * tmpcoef;
		}
		retval += tmplap.MagnitudeSq();

	}

	return retval;

}


// Find the faces touching each vertex
void PlyMeshIO::computeAdjacentfaces()
{
	if (!m_adjacentfaces.empty())
		return;
	
	printf("Finding vertex to triangle maps... ");
	int nv = m_vertices.size(), nf = m_faces.size();

	vector<int> numadjacentfaces(nv);
	for (int i = 0; i < nf; i++) {
		numadjacentfaces[m_faces[i][0]]++;
		numadjacentfaces[m_faces[i][1]]++;
		numadjacentfaces[m_faces[i][2]]++;
	}

	m_adjacentfaces.resize(m_vertices.size());
	for (int i = 0; i < nv; i++)
		m_adjacentfaces[i].reserve(numadjacentfaces[i]);

	for (int i = 0; i < nf; i++) {
		for (int j = 0; j < 3; j++)
			m_adjacentfaces[m_faces[i][j]].push_back(i);
	}

	printf("Done.\n");
}

bool PlyMeshIO::read_verts_asc(FILE *f, 
	int nverts, int vert_len, int vert_pos, int vert_norm,
	int vert_color, bool float_color, int vert_conf, int vert_uv)
{
	if (nverts <= 0 || vert_len < 3 || vert_pos < 0)
		return false;

	int old_nverts = m_vertices.size();
	int new_nverts = old_nverts + nverts;
	m_vertices.resize(new_nverts);
	if (vert_norm > 0)
		m_normals.resize(new_nverts);
	if (vert_color > 0)
		m_colors.resize(new_nverts);
	if (vert_conf > 0)
		m_confidences.resize(new_nverts);
	if (vert_uv > 0)
		m_uvcoord.resize(new_nverts);

	char buf[1024];
	skip_comments(f);
	printf("\n  Reading %d vertices... ", nverts);
	for (int i = old_nverts; i < new_nverts; i++) {
		for (int j = 0; j < vert_len; j++) {
			if (j == vert_pos) {
				if (fscanf(f, "%f %f %f",
					&m_vertices[i][0],
					&m_vertices[i][1],
					&m_vertices[i][2]) != 3)
					return false;
				j += 2;
			}
			else if (j == vert_norm) {
				if (fscanf(f, "%f %f %f",
					&m_normals[i][0],
					&m_normals[i][1],
					&m_normals[i][2]) != 3)
					return false;
				j += 2;
			}
			else if (j == vert_color && float_color) {
				float r, g, b;
				if (fscanf(f, "%f %f %f", &r, &g, &b) != 3)
					return false;
				m_colors[i] = CVec3f(r, g, b);
				j += 2;
			}
			else if (j == vert_color && !float_color) {
				int r, g, b;
				if (fscanf(f, "%d %d %d", &r, &g, &b) != 3)
					return false;
				m_colors[i] = CVec3f(r/255.0f, g/255.0f, b/255.0f);
				j += 2;
			}
			else if (j == vert_conf) {
				if (fscanf(f, "%f", &m_confidences[i]) != 1)
					return false;
			}
			else if (j == vert_uv) {
				if (fscanf(f, "%f %f",
					&m_uvcoord[i][0],
					&m_uvcoord[i][1]) != 2)
					return false;
				j += 1;
			}
			else {
				fscanf(f, " %1024s", buf);
			}
		}
	}

	return true;
}







bool PlyMeshIO::read_faces_bin(FILE *f, bool need_swap,
	int nfaces, int face_len, int face_count, int face_idx)
{
	if (nfaces < 0 || face_idx < 0)
		return false;

	if (nfaces == 0)
		return true;

	printf("\n  Reading %d faces... ", nfaces);

	int old_nfaces = m_faces.size();
	int new_nfaces = old_nfaces + nfaces;
	m_faces.reserve(new_nfaces);

	// face_len doesn't include the indices themeselves, since that's
	// potentially variable-length
	int face_skip = face_len - face_idx;

	vector<unsigned char> buf(max(face_idx, face_skip));
	vector<int> thisface;
	for (int i = 0; i < nfaces; i++) {
		COND_READ(face_idx > 0, buf[0], face_idx);

		unsigned this_ninds = 3;
		if (face_count >= 0) {
			// Read count - either 1 or 4 bytes
			if (face_idx - face_count == 4) {
				this_ninds = *(unsigned *)&(buf[face_count]);
				if (need_swap)
					swap_unsigned(this_ninds);
			}
			else {
				this_ninds = buf[face_count];
			}
		}
		thisface.resize(this_ninds);
		COND_READ(true, thisface[0], 4 * this_ninds);
		if (need_swap) {
			for (size_t j = 0; j < thisface.size(); j++)
				swap_int(thisface[j]);
		}
		tess(m_vertices, thisface, m_faces);
		COND_READ(face_skip > 0, buf[0], face_skip);
	}

	return true;
}


// Read a bunch of faces from an ASCII file
bool PlyMeshIO::read_faces_asc(FILE *f, int nfaces,
	int face_len, int face_count, int face_idx, bool read_to_eol /* = false */)
{
	if (nfaces < 0 || face_idx < 0)
		return false;

	if (nfaces == 0)
		return true;

	int old_nfaces = m_faces.size();
	int new_nfaces = old_nfaces + nfaces;
	m_faces.reserve(new_nfaces);

	char buf[1024];
	skip_comments(f);
	printf("\n  Reading %d faces... ", nfaces);
	vector<int> thisface;
	for (int i = 0; i < nfaces; i++) {
		thisface.clear();
		int this_face_count = 3;
		for (int j = 0; j < face_len + this_face_count; j++) {
			if (j >= face_idx && j < face_idx + this_face_count) {
				thisface.push_back(0);
				if (!fscanf(f, " %d", &(thisface.back()))) {
					printf("Couldn't read vertex index %d for face %d\n",
						j - face_idx, i);
					return false;
				}
			}
			else if (j == face_count) {
				if (!fscanf(f, " %d", &this_face_count)) {
					printf("Couldn't read vertex count for face %d\n", i);
					return false;
				}
			}
			else {
				fscanf(f, " %s", buf);
			}
		}
		tess(m_vertices, thisface, m_faces);
		if (read_to_eol) {
			while (1) {
				int c = fgetc(f);
				if (c == EOF || c == '\n')
					break;
			}
		}
	}

	return true;
}


void PlyMeshIO::loadPlyMesh(const std::string &plyname)
{
	FILE *pfile = fopen(plyname.c_str(), "rb");

	if (pfile == NULL)
	{
		std::cout << "Error reading file ... " << plyname << std::endl;
		return;
	}

	int c = fgetc(pfile);
	if (c == EOF) {
		fprintf(stderr, "Can't read header\n");
		return;
	}

	if (c == 'p') {
		// See if it's a ply file
		char buf[4];
		if (!fgets(buf, 4, pfile)) {
			fprintf(stderr, "Can't read header\n");
			return;
		}
		if (strncmp(buf, "ly", 2) == 0)
			read_ply(pfile);
	}
	

	fclose(pfile);


}


void PlyMeshIO::writePlyMesh(const std::string &plyname, bool binary, bool write_norm ,bool float_color)
{
	std::cout << "writing ply mesh " << plyname << "...";
	FILE *pfile = fopen(plyname.c_str(), "wb");

	if (pfile == NULL)
	{
		std::cout << "Error writing file ... " << plyname << std::endl;
		return;
	}
	
	if (binary)
		write_ply_binary(pfile, we_are_little_endian(), write_norm, float_color);
	else
		write_ply_ascii(pfile, write_norm, float_color);

	fclose(pfile);

	std::cout << std::endl;


}

// Read a ply file
bool PlyMeshIO::read_ply(FILE *f)
{
	char buf[1024];
	bool binary = false, need_swap = false, float_color = false;
	int result, nverts = 0, nfaces = 0, nstrips = 0, ngrid = 0;
	int vert_len = 0, vert_pos = -1, vert_norm = -1;
	int vert_color = -1, vert_conf = -1;
	int vert_uv = -1;
	int face_len = 0, face_count = -1, face_idx = -1;

	// Read file format
	GET_LINE();
	while (buf[0] && isspace(buf[0]))
		GET_LINE();
	if (LINE_IS("format binary_big_endian 1.0")) {
		binary = true;
		need_swap = we_are_little_endian();
	}
	else if (LINE_IS("format binary_little_endian 1.0")) {
		binary = true;
		need_swap = !we_are_little_endian();
	}
	else if (LINE_IS("format ascii 1.0")) {
		binary = false;
	}
	else {
		fprintf(stderr, "Unknown ply format or version\n");
		return false;
	}

	int grid_width;
	int grid_height;

	// Skip comments and unknown obj_info lines
	GET_LINE();
	while (LINE_IS("obj_info") || LINE_IS("comment")) {
		if (LINE_IS("obj_info num_cols"))
			sscanf(buf, "obj_info num_cols %d", &grid_width);
		if (LINE_IS("obj_info num_rows"))
			sscanf(buf, "obj_info num_rows %d", &grid_height);
		GET_LINE();
	}

	// Skip until we find vertices
	int skip1 = 0;
	while (!LINE_IS("end_header") && !LINE_IS("element vertex")) {
		char elem_name[1024];
		int nelem = 0, elem_len = 0;
		sscanf(buf, "element %s %d", elem_name, &nelem);
		GET_LINE();
		while (LINE_IS("property")) {
			if (!ply_property(buf, elem_len, binary))
				return false;
			GET_LINE();
		}
		skip1 += nelem * elem_len;
	}

	// Find number of vertices
	result = sscanf(buf, "element vertex %d\n", &nverts);
	if (result != 1) {
		fprintf(stderr, "Expected \"element vertex\"\n");
		return false;
	}

	// Parse vertex properties
	GET_LINE();
	while (LINE_IS("property")) {
		if (LINE_IS("property float x") ||
			LINE_IS("property float32 x"))
			vert_pos = vert_len;
		if (LINE_IS("property float nx") ||
			LINE_IS("property float32 nx"))
			vert_norm = vert_len;
		if (LINE_IS("property uchar diffuse_red") ||
			LINE_IS("property uint8 diffuse_red") ||
			LINE_IS("property uchar red") ||
			LINE_IS("property uint8 red"))
			vert_color = vert_len;
		if (LINE_IS("property float diffuse_red") ||
			LINE_IS("property float32 diffuse_red") ||
			LINE_IS("property float red") ||
			LINE_IS("property float32 red"))
			vert_color = vert_len, float_color = true;
		if (LINE_IS("property float confidence") ||
			LINE_IS("property float32 confidence"))
			vert_conf = vert_len;
		if (LINE_IS("property float texture_u") ||
			LINE_IS("property float32 texture_u"))
			vert_uv = vert_len;

		if (!ply_property(buf, vert_len, binary))
			return false;

		GET_LINE();
	}

	// Skip until we find faces
	int skip2 = 0;
	while (!LINE_IS("end_header") && !LINE_IS("element face") &&
		!LINE_IS("element tristrips") && !LINE_IS("element range_grid")) {
		char elem_name[1024];
		int nelem = 0, elem_len = 0;
		sscanf(buf, "element %s %d", elem_name, &nelem);
		GET_LINE();
		while (LINE_IS("property")) {
			if (!ply_property(buf, elem_len, binary))
				return false;
			GET_LINE();
		}
		skip2 += nelem * elem_len;
	}


	// Look for faces, tristrips, or range grid
	if (LINE_IS("element face")) {
		if (sscanf(buf, "element face %d\n", &nfaces) != 1)
			return false;
		GET_LINE();
		while (LINE_IS("property")) {
			if (LINE_IS("property list uchar int vertex_indices") ||
				LINE_IS("property list uint8 int32 vertex_indices") ||
				LINE_IS("property list char int vertex_indices") ||
				LINE_IS("property list int8 int32 vertex_indices") ||
				LINE_IS("property list uchar int vertex_index") ||
				LINE_IS("property list uint8 int32 vertex_index") ||
				LINE_IS("property list char int vertex_index") ||
				LINE_IS("property list int8 int32 vertex_index")) {
				face_count = face_len;
				face_idx = face_len + 1;
				face_len += 1;
			}
			else if
				(LINE_IS("property list uint int vertex_indices") ||
				LINE_IS("property list uint32 int32 vertex_indices") ||
				LINE_IS("property list int int vertex_indices") ||
				LINE_IS("property list int32 int32 vertex_indices") ||
				LINE_IS("property list uint int vertex_index") ||
				LINE_IS("property list uint32 int32 vertex_index") ||
				LINE_IS("property list int int vertex_index") ||
				LINE_IS("property list int32 int32 vertex_index")) {
				face_count = face_len;
				face_idx = face_len + (binary ? 4 : 1);
				face_len += (binary ? 4 : 1);
			}
			else if (!ply_property(buf, face_len, binary))
				return false;
			GET_LINE();
		}
	}
	else if (LINE_IS("element tristrips")) {
		nstrips = 1;
		GET_LINE();
		if (!LINE_IS("property list int int vertex_indices") &&
			!LINE_IS("property list int32 int32 vertex_indices"))
			return false;
		GET_LINE();
	}
	else if (LINE_IS("element range_grid")) {
		if (sscanf(buf, "element range_grid %d\n", &ngrid) != 1)
			return false;
		if (ngrid != grid_width*grid_height) {
			fprintf(stderr, "Range grid size does not equal num_rows*num_cols\n");
			return false;
		}
		GET_LINE();
		if (!LINE_IS("property list uchar int vertex_indices") &&
			!LINE_IS("property list uint8 int32 vertex_indices") &&
			!LINE_IS("property list char int vertex_indices") &&
			!LINE_IS("property list int8 int32 vertex_indices"))
			return false;
		GET_LINE();
	}

	while (LINE_IS("property")) {
		if (!ply_property(buf, face_len, binary))
			return false;
		GET_LINE();
	}

	// Skip to the end of the header
	while (!LINE_IS("end_header"))
		GET_LINE();
	if (binary && buf[10] == '\r') {
		fprintf(stderr, "Warning!  Possibly corrupt file\n");
		fprintf(stderr, "     If things don't work, make sure this file was transferred in BINARY, not ASCII mode\n");
	}


	// Actually read everything in
	if (skip1) {
		if (binary)
			fseek(f, skip1, SEEK_CUR);
		else
			for (int i = 0; i < skip1; i++)
				fscanf(f, "%s", buf);
	}
	if (binary) {
		if (!read_verts_bin(f,need_swap, nverts, vert_len,
			vert_pos, vert_norm, vert_color,
			float_color, vert_conf, vert_uv))
			return false;
	}
	else {
		if (!read_verts_asc(f, nverts, vert_len,
			vert_pos, vert_norm, vert_color,
			float_color, vert_conf, vert_uv))
			return false;
	}

	if (skip2) {
		if (binary)
			fseek(f, skip2, SEEK_CUR);
		else
			for (int i = 0; i < skip2; i++)
				fscanf(f, "%s", buf);
	}

	if (ngrid) {
		printf("GRID INPUT NOT SUPPORTED!!!ERROR!\n");
		return false;

	}
	else if (nstrips) {
		printf("STRIP INPUT NOT SUPPORTED!!!ERROR!\n");
		return false;
	}
	else if (nfaces) {
		if (binary) {
			if (!read_faces_bin(f,  need_swap, nfaces,
				face_len, face_count, face_idx))
				return false;
		}
		else {
			if (!read_faces_asc(f,  nfaces,
				face_len, face_count, face_idx))
				return false;
		}
	}

	return true;
}



// Write a bunch of faces to a binary file
void PlyMeshIO::write_faces_bin(FILE *f, bool need_swap,
	int before_face_len, const char *before_face,
	int after_face_len, const char *after_face)
{	
	if (need_swap) {
		for (int i = 0; i < m_faces.size(); i++) {
			swap_int(m_faces[i][0]);
			swap_int(m_faces[i][1]);
			swap_int(m_faces[i][2]);
		}
	}
	for (int i = 0; i < m_faces.size(); i++) {
		if (before_face_len)
			fwrite(before_face, before_face_len, 1, f);
		fwrite(&(m_faces[i][0]), 12, 1, f);
		if (after_face_len)
			fwrite(after_face, after_face_len, 1, f);
	}
	if (need_swap) {
		for (int i = 0; i < m_faces.size(); i++) {
			swap_int(m_faces[i][0]);
			swap_int(m_faces[i][1]);
			swap_int(m_faces[i][2]);
		}
	}
}

// Write a bunch of vertices to a binary file
void PlyMeshIO::write_verts_bin(FILE *f, bool need_swap,
	bool write_norm, bool write_color, bool float_color, bool write_conf)
{
	if (need_swap) {
		for (int i = 0; i < m_vertices.size(); i++) {
			swap_float(m_vertices[i][0]);
			swap_float(m_vertices[i][1]);
			swap_float(m_vertices[i][2]);
		}
		if (!m_normals.empty()) {
			for (int i = 0; i < m_normals.size(); i++) {
				swap_float(m_normals[i][0]);
				swap_float(m_normals[i][1]);
				swap_float(m_normals[i][2]);
			}
		}
		if (!m_colors.empty() && float_color) {
			for (int i = 0; i < m_normals.size(); i++) {
				swap_float(m_colors[i][0]);
				swap_float(m_colors[i][1]);
				swap_float(m_colors[i][2]);
			}
		}
		if (!m_confidences.empty()) {
			for (int i = 0; i < m_confidences.size(); i++)
				swap_float(m_confidences[i]);
		}
	}
	if ((m_normals.empty() || !write_norm) &&
		(m_colors.empty() || !write_color) &&
		(m_confidences.empty() || !write_conf)) {
		// Optimized vertex-only code
		fwrite(&(m_vertices[0][0]), 12 * m_vertices.size(), 1, f);
	}
	else {
		// Generic code
		for (int i = 0; i < m_vertices.size(); i++) {
			fwrite(&(m_vertices[i][0]), 12, 1, f);
			if (!m_normals.empty() && write_norm)
				fwrite(&(m_normals[i][0]), 12, 1, f);
			if (!m_colors.empty() && write_color&& float_color)
				fwrite(&(m_colors[i][0]), 12, 1, f);			
			if (!m_colors.empty() && write_color && !float_color) {
				char c[3] = {
					color2uchar(m_colors[i][0]),
					color2uchar(m_colors[i][1]),
					color2uchar(m_colors[i][2]) };
				fwrite(&c, 3, 1, f);
			}
			if (!m_confidences.empty() && write_conf)
				fwrite(&(m_confidences[i]), 4, 1, f);
		}
	}
	if (need_swap) {
		for (int i = 0; i < m_vertices.size(); i++) {
			swap_float(m_vertices[i][0]);
			swap_float(m_vertices[i][1]);
			swap_float(m_vertices[i][2]);
		}
		if (!m_normals.empty()) {
			for (int i = 0; i < m_normals.size(); i++) {
				swap_float(m_normals[i][0]);
				swap_float(m_normals[i][1]);
				swap_float(m_normals[i][2]);
			}
		}
		if (!m_colors.empty() && float_color) {
			for (int i = 0; i < m_normals.size(); i++) {
				swap_float(m_colors[i][0]);
				swap_float(m_colors[i][1]);
				swap_float(m_colors[i][2]);
			}
		}
		if (!m_confidences.empty()) {
			for (int i = 0; i < m_confidences.size(); i++)
				swap_float(m_confidences[i]);
		}
	}
}

void PlyMeshIO::write_verts_asc(FILE *f,
	const char *before_vert,
	const char *before_norm,
	const char *before_color,
	bool float_color,
	const char *before_conf,
	const char *after_line)
{
	for (int i = 0; i < m_vertices.size(); i++) {
		fprintf(f, "%s%.7g %.7g %.7g", before_vert,
			m_vertices[i][0],
			m_vertices[i][1],
			m_vertices[i][2]);
		if (!m_normals.empty() && before_norm)
			fprintf(f, "%s%.7g %.7g %.7g", before_norm,
			m_normals[i][0],
			m_normals[i][1],
			m_normals[i][2]);
		if (!m_colors.empty() && before_color && float_color)
			fprintf(f, "%s%.7g %.7g %.7g", before_color,
			m_colors[i][0],
			m_colors[i][1],
			m_colors[i][2]);	
		if (!m_colors.empty() && before_color && !float_color)
			fprintf(f, "%s%d %d %d", before_color,
			color2uchar(m_colors[i][0]),
			color2uchar(m_colors[i][1]),
			color2uchar(m_colors[i][2]));
		if (!m_confidences.empty() && before_conf)
			fprintf(f, "%s%.7g", before_conf, m_confidences[i]);
		fprintf(f, "%s\n", after_line);
	}
}

// Write a ply header
void PlyMeshIO::write_ply_header(FILE *f, const char *format, bool write_norm,  bool float_color)
{
	fprintf(f, "ply\nformat %s 1.0\n", format);	
	fprintf(f, "element vertex %lu\n",
		(unsigned long)m_vertices.size());
	fprintf(f, "property float x\n");
	fprintf(f, "property float y\n");
	fprintf(f, "property float z\n");
	if (write_norm && !m_normals.empty()) {
		fprintf(f, "property float nx\n");
		fprintf(f, "property float ny\n");
		fprintf(f, "property float nz\n");
	}
	if (!m_colors.empty() && float_color) {
		fprintf(f, "property float diffuse_red\n");
		fprintf(f, "property float diffuse_green\n");
		fprintf(f, "property float diffuse_blue\n");
	}
	if (!m_colors.empty() && !float_color) {
		fprintf(f, "property uchar diffuse_red\n");
		fprintf(f, "property uchar diffuse_green\n");
		fprintf(f, "property uchar diffuse_blue\n");
	}
	if (!m_confidences.empty()) {
		fprintf(f, "property float confidence\n");
	}
	fprintf(f, "element face %lu\n",
		(unsigned long)m_faces.size());
	fprintf(f, "property list uchar int vertex_indices\n");
	
	fprintf(f, "end_header\n");
}


void PlyMeshIO::write_faces_asc(FILE *f, const char *before_face, const char *after_line)
{
	for (int i = 0; i < m_faces.size(); i++) {
		fprintf(f, "%s%d %d %d%s\n", before_face, m_faces[i][0],
			m_faces[i][1], m_faces[i][2], after_line);
	}
}

void PlyMeshIO::write_ply_ascii(FILE *f, bool write_norm, bool float_color)
{
	if (write_norm && m_normals.empty())
		computeNormals();

	write_ply_header(f, "ascii", write_norm, float_color);
	write_verts_asc(f, "", write_norm ? " " : 0, " ", float_color, " ", "");
	write_faces_asc( f, "3 ", "");
	
}


void PlyMeshIO::write_ply_binary(FILE *f, bool need_swap, bool write_norm, bool float_color)
{
	if (write_norm && m_normals.empty())
		computeNormals();
	const char *format = (need_swap ^ we_are_little_endian()) ?
		"binary_little_endian" : "binary_big_endian";
	
	write_ply_header(f, format, write_norm,float_color);
	write_verts_bin(f, need_swap, write_norm, true,  float_color,true);
	
	char buf[1] = { 3 };
	write_faces_bin(f, need_swap, 1, buf, 0, 0);

}



// Remap vertices according to the given table
//
// Faces are renumbered to reflect the new numbering of vertices, and any
// faces that included a vertex that went away will also be removed.
//
// Any per-vertex properties are renumbered along with the vertices.
void PlyMeshIO::remap_verts(const std::vector<int> &remap_table)
{
	int nv = m_vertices.size();
	if (remap_table.size() != nv) {
		printf("remap_verts called with wrong table size!\n");
		return;
	}

	// Check what we're doing
	bool removing_any = false;
	int last = -1;
	for (int i = 0; i < nv; i++) {
		if (remap_table[i] < 0)
			removing_any = true;
		else if (remap_table[i] > last)
			last = remap_table[i];
	}

	// Figure out what we have sitting around, so we can remap/recompute
	bool have_faces = !m_faces.empty();
	bool have_col = !m_colors.empty();
	bool have_conf = !m_confidences.empty();	
	bool have_normals = !m_normals.empty();
	

	// Remap the vertices and per-vertex properties
	PlyMeshIO oldmesh = *this;
	

#define REMAP(property) this->property[remap_table[i]] = oldmesh.property[i]
	for (int i = 0; i < nv; i++) {
		if (remap_table[i] < 0 || remap_table[i] == i)
			continue;
		REMAP(m_vertices);
		if (have_col) REMAP(m_colors);
		if (have_conf) REMAP(m_confidences);
		if (have_normals) REMAP(m_normals);
	}

#define ERASE(property) this->property.erase(this->property.begin()+last+1, \
	this->property.end())
	ERASE(m_vertices);
	if (have_col) ERASE(m_colors);
	if (have_conf) ERASE(m_confidences);	
	if (have_normals) ERASE(m_normals);
	
	//std::cout << this->m_faces.size() << std::endl;
	// Renumber faces
	int nextface = 0;
	for (int i = 0; i < this->m_faces.size(); i++) {
		int n0 = (this->m_faces[nextface][0] = remap_table[oldmesh.m_faces[i][0]]);
		int n1 = (this->m_faces[nextface][1] = remap_table[oldmesh.m_faces[i][1]]);
		int n2 = (this->m_faces[nextface][2] = remap_table[oldmesh.m_faces[i][2]]);
		if ((n0 != -1) && (n1 != -1) && (n2 != -1))
			nextface++;
	}
	this->m_faces.erase(this->m_faces.begin() + nextface, this->m_faces.end());
	//std::cout << this->m_faces.size() << std::endl;

	
	if (!this->m_neighbors.empty()) {
		this->m_neighbors.clear();
		computeNeighbors();
	}
	if (!this->m_adjacentfaces.empty()) {
		this->m_adjacentfaces.clear();
		computeAdjacentfaces();
	}
	

	if (!have_faces)
		this->m_faces.clear();

	//this->m_colors.clear();

	
}


void PlyMeshIO::NaNRemove()
{
	int count = 0;
	int numvertices = m_vertices.size();
	vector<int> remap_table(numvertices, -1);
	for (int i = 0; i < numvertices; i++)
	{
		if (isnan(m_vertices[i][0]) || isnan(m_vertices[i][1]) || isnan(m_vertices[i][2]))
		{
			remap_table[i] = -1;
		}
		else
		{
			remap_table[i] = count;
			count += 1;
		}
	}

	remap_verts(remap_table);

}


void PlyMeshIO::remove_vertices(const vector<bool> &toremove)
{
	int nv = m_vertices.size();

	// Build a table that tells how the vertices will be remapped
	if (!nv)
		return;

	printf("Removing vertices... ");
	vector<int> remap_table(nv);
	int next = 0;
	for (int i = 0; i < nv; i++) {
		if (toremove[i])
			remap_table[i] = -1;
		else
			remap_table[i] = next++;
	}

	// Nothing to delete?
	if (next == nv) {
		printf("None removed.\n");
		return;
	}

	remap_verts(remap_table);

	printf("%d vertices removed... Done.\n", nv - next);
}


// Remove vertices that aren't referenced by any face
void PlyMeshIO::remove_unused_vertices()
{
	int nv = m_vertices.size();
	if (!nv)
		return;

	bool had_faces = !m_faces.empty();
	vector<bool> unused(nv, true);
	for (int i = 0; i < m_faces.size(); i++) {
		unused[m_faces[i][0]] = false;
		unused[m_faces[i][1]] = false;
		unused[m_faces[i][2]] = false;
	}
	remove_vertices(unused);
	if (!had_faces)
		m_faces.clear();
}




void PlyMeshIO::remove_duplicated_vertices()
{
	int nv = m_vertices.size();
	if (!nv)
		return;
	computeNeighbors();
	
	vector<bool> unused(nv, false);
	vector<int> vec_map(nv, -1);
	for (int v = 0; v < m_vertices.size(); v++)
	{
		const vector<int> &vectmplist = m_neighbors[v];
		for (int j = 0; j < vectmplist.size(); j++)
		{
			CVec3f tmpvetctr = m_vertices[v];
			if (vectmplist[j]>v)
			{
				CVec3f tmpvetlow = m_vertices[vectmplist[j]];
				if ((tmpvetctr - tmpvetlow).Magnitude() <FLOAT_EPSILON){
					unused[vectmplist[j]] = true;
					if (vec_map[v] >= 0)
						vec_map[vectmplist[j]] = vec_map[v];
					else
						vec_map[vectmplist[j]] = v;
				}
			}
		}
	}
	m_neighbors.clear();
	
	//remove_vertices(unused);
	printf("Removing duplicated vertices... ");
	vector<int> remap_table(nv);
	int next = 0;
	for (int i = 0; i < nv; i++) {
		if (unused[i])
			remap_table[i] = -1;
		else
			remap_table[i] = next++;
	}

	// Nothing to delete?
	if (next == nv) {
		printf("None removed.\n");
		return;
	}
	for (int i = 0; i < vec_map.size(); i++)
	{
		if (vec_map[i] < 0)
			continue;
		else
		{
			//std::cout << remap_table[i] << " vs " << remap_table[vec_map[i]] << std::endl;
			remap_table[i] = remap_table[vec_map[i]];
		}
	}

	remap_verts(remap_table);

	printf("%d vertices removed... Done.\n", nv - next);

	int nf = m_faces.size();
	vector<bool> vecb_removeface(nf, false);
	for (int i = 0; i < nf; i++)
	{
		if (m_faces[i][0] == m_faces[i][1]){
			vecb_removeface[i] = true;
			continue;
		}
		if (m_faces[i][0] == m_faces[i][2]){
			vecb_removeface[i] = true;
			continue;
		}
		if (m_faces[i][2] == m_faces[i][1]){
			vecb_removeface[i] = true;
			continue;
		}
	}
	remove_faces(vecb_removeface);
	
}


// Remove faces as indicated by toremove.  Should probably be
// followed by a call to remove_unused_vertices()
void PlyMeshIO::remove_faces(const vector<bool> &toremove)
{	
	bool had_faces = !m_faces.empty();	
	int numfaces = m_faces.size();
	if (!numfaces)
		return;
	
	m_adjacentfaces.clear();
	m_neighbors.clear();
	
	printf("Removing faces... ");
	int next = 0;
	for (int i = 0; i < numfaces; i++) {
		if (toremove[i])
			continue;
		m_faces[next++] = m_faces[i];
	}
	if (next == numfaces) {
		printf("None removed.\n");
		return;
	}

	m_faces.erase(m_faces.begin() + next, m_faces.end());
	printf("%d faces removed... Done.\n", numfaces - next);
		
	if (!had_faces)
		m_faces.clear();
}









// Helper class for comparing two integers by finding the elements at those
// indices within some array and comparing them
template <class Array>
class CompareArrayElements {
private:
	const Array &a;
public:
	CompareArrayElements(const Array &_a) : a(_a)
	{}
	bool operator () (int i1, int i2) const
	{
		return (a[i1] > a[i2]);
	}
};

// Helper function for find_comps, below.  Sorts the connected components
// from largest to smallest.  Renumbers the elements of compsizes to
// reflect this new numbering.
static void sort_comps(vector<int> &comps, vector<int> &compsizes)
{
	vector<int> comp_pointers(compsizes.size());
	for (size_t i = 0; i < comp_pointers.size(); i++)
		comp_pointers[i] = i;

	sort(comp_pointers.begin(), comp_pointers.end(),
		CompareArrayElements< vector<int> >(compsizes));

	vector<int> remap_table(comp_pointers.size());
	for (size_t i = 0; i < comp_pointers.size(); i++)
		remap_table[comp_pointers[i]] = i;
	for (size_t i = 0; i < comps.size(); i++)
		comps[i] = remap_table[comps[i]];

	vector<int> newcompsizes(compsizes.size());
	for (size_t i = 0; i < compsizes.size(); i++)
		newcompsizes[i] = compsizes[comp_pointers[i]];
	compsizes = newcompsizes;
}



// Are two faces connected along an edge (or vertex)?
bool PlyMeshIO::connected(int f1, int f2, bool conn_vert)
{
	int f10 = m_faces[f1][0], f11 = m_faces[f1][1], f12 = m_faces[f1][2];
	int f20 = m_faces[f2][0], f21 = m_faces[f2][1], f22 = m_faces[f2][2];

	if (conn_vert)
		return f10 == f20 || f10 == f21 || f10 == f22 ||
		f11 == f20 || f11 == f21 || f11 == f22 ||
		f12 == f20 || f12 == f21 || f12 == f22;
	else
		return (f10 == f20 && (f11 == f22 || f12 == f21)) ||
		(f10 == f21 && (f11 == f20 || f12 == f22)) ||
		(f10 == f22 && (f11 == f21 || f12 == f20)) ||
		(f11 == f20 && f12 == f22) ||
		(f11 == f21 && f12 == f20) ||
		(f11 == f22 && f12 == f21);
}


// Helper function for find_comps, below.  Finds and marks all the faces
// connected to f.
void PlyMeshIO::find_connected(vector<int> &comps, vector<int> &compsizes,int f, int whichcomponent, bool conn_vert)
{
	stack<int> s;
	s.push(f);
	while (!s.empty()) {
		int currface = s.top();
		s.pop();
		for (int i = 0; i < 3; i++) {
			int vert = m_faces[currface][i];
			FOR_EACH_ADJACENT_FACE(m_adjacentfaces, vert, adjface) {
				if (comps[adjface] != -1 || !connected(adjface, currface, conn_vert))
					continue;
				comps[adjface] = whichcomponent;
				compsizes[whichcomponent]++;
				s.push(adjface);
			}
		}
	}
}


int PlyMeshIO::find_vetex_connected(vector<int> &comps, vector<int> &compsizes, int v, int whichcomponent, int upboundnum)
{
	//stack<int> s;
	queue<int> q;
	q.push(v);
	//s.push(v);
	while (!q.empty()) {
		int currvet = q.front();
		q.pop();
		for (size_t v_ind = 0; v_ind < m_neighbors[currvet].size(); v_ind++)
		{
			int adjvet = m_neighbors[currvet][v_ind];
			if (comps[adjvet] != -1)
				continue;

			if (compsizes[whichcomponent] == upboundnum)
			{
				return adjvet;
			}

			comps[adjvet] = whichcomponent;
			compsizes[whichcomponent]++;
			q.push(adjvet);
		}

	}

	return -1;
}




// Find the connected components of TriMesh "in".
// Considers components to be connected if they touch at a vertex if
//  conn_vert == true, else they need to touch at an edge.
// Outputs:
//  comps is a vector that gives a mapping from each face to its
//   associated connected component.
//  compsizes holds the size of each connected component.
// Connected components are sorted from largest to smallest.
void PlyMeshIO::find_comps(vector<int> &comps, vector<int> &compsizes,bool conn_vert /* = false */)
{
	if (m_vertices.empty())
		return;	
	if (m_faces.empty())
		return;
	computeAdjacentfaces();	

	int nf = m_faces.size();
	comps.clear();
	comps.reserve(nf);
	comps.resize(nf, -1);
	compsizes.clear();

	for (int i = 0; i < nf; i++) {
		if (comps[i] != -1)
			continue;
		int comp = compsizes.size();
		comps[i] = comp;
		compsizes.push_back(1);
		find_connected(comps, compsizes, i, comp, conn_vert);
	}

	if (compsizes.size() > 1)
		sort_comps(comps, compsizes);

	m_adjacentfaces.clear();
}


void PlyMeshIO::find_vertex_comps(vector<int> &comps, vector<int> &compsizes, int upboundnum)
{
	if (m_vertices.empty())
		return;
	if (m_faces.empty())
		return;
	computeNeighbors();

	int nv = m_vertices.size();
	comps.clear();
	comps.reserve(nv);
	comps.resize(nv, -1);
	compsizes.clear();

	for (int i = 0; i < nv; i++) {
		if (comps[i] != -1)
			continue;
		int retval = i;
		do{
			int comp = compsizes.size();
			comps[retval] = comp;
			compsizes.push_back(1);
			retval = find_vetex_connected(comps, compsizes, retval, comp, upboundnum);
		} while (retval >= 0);
		

	}

	if (compsizes.size() > 1)
		sort_comps(comps, compsizes);

	m_neighbors.clear();
}




// Select the connected components no smaller than min_size (but no more than
// total_largest components), and delete all other vertices from the mesh.
// Updates comps and compsizes.

void PlyMeshIO::select_big_comps(const vector<int> &comps, const vector<int> &compsizes, int min_size, int total_largest /* = std::numeric_limits<int>::max() */)
{
	int ncomp = compsizes.size();
	int keep_last = min(ncomp - 1, total_largest - 1);
	while (keep_last > -1 && compsizes[keep_last] < min_size)
		keep_last--;

	int numfaces = m_faces.size();
	vector<bool> toremove(numfaces, false);
	for (int i = 0; i < numfaces; i++) {
		if (comps[i] > keep_last)
			toremove[i] = true;
	}

	remove_faces(toremove);
	remove_unused_vertices();
}

void PlyMeshIO::select_big_comps_auto(const vector<int> &comps, const vector<int> &compsizes, float ratio)
{
	int ncomp = compsizes.size();
	if (ncomp == 1)
		return;

	int basesize = compsizes[0];
	int keep_last = 0;
	for (int i = 1; i<ncomp; i++)
	{
		if (compsizes[i]>(basesize*ratio))
		{
			keep_last += 1;
			basesize = compsizes[i];
		}
		else
			break;
	}

	std::cout << "valid connect region up to " << keep_last << std::endl;

	int numfaces = m_faces.size();
	vector<bool> toremove(numfaces, false);
	for (int i = 0; i < numfaces; i++) {
		if (comps[i] > keep_last)
			toremove[i] = true;
	}

	remove_faces(toremove);
	remove_unused_vertices();
}


void PlyMeshIO::select_biggest_comps()
{
	std::cout << "selectting the biggest comps...";

	// Find connected components
	vector<int> comps;
	vector<int> compsizes;
	bool conn_vert = true;
	int total = BIGNUM;
	find_comps(comps, compsizes, conn_vert);

	int nf = m_faces.size();
	//select_big_comps(comps, compsizes, nf/2 , total);
	select_big_comps_auto(comps, compsizes, 0.5f);

	remove_duplicated_vertices();
	
	std::cout <<"Done!"<<std::endl;
	
}


void PlyMeshIO::reOrderViaGraphGrouping(int upboundnum)
{
	std::cout << "reOrderViaGraphGrouping ...";
	vector<int> comps;
	vector<int> compsizes;
	
	find_vertex_comps(comps, compsizes, upboundnum);

	int numvertices = m_vertices.size();
	m_colors.resize(numvertices, CVec3f(0, 0, 0));

	vector<vector<int> > vec_clustervetind(compsizes.size());	
	for (int i = 0; i < numvertices; i++)
	{
		int tmpcltind = comps[i];
		if (tmpcltind < 0 || tmpcltind >= compsizes.size())
		{
			std::cout << "Error ! Mesh is not one manifold! Plz run find the biggest connect component first " << std::endl;
			continue;
		}
		vec_clustervetind[tmpcltind].push_back(i);
	}

	vector<int> vec_relposind(compsizes.size(), 0);
	//if (vec_relposind.size() >= 1)
	//	vec_relposind[0] = 0;
	for (int i = 1; i < compsizes.size(); i++)
	{
		vec_relposind[i] = vec_relposind[i - 1] + compsizes[i-1];
	}


	vector<int> remap_table(numvertices,-1);
	for (int i = 0; i < compsizes.size(); i++)
	{
		for (int j = 0; j < vec_clustervetind[i].size(); j++)
		{
			remap_table[vec_clustervetind[i][j]] = vec_relposind[i] + j;
		}
	}

	remap_verts(remap_table);

	//std::cout << "Number of Cluster = " << compsizes.size() << std::endl;
	//int numclusters = 0;
	//for (int i = 0; i < compsizes.size(); i++)
	//{
	//	if (compsizes[i]>upboundnum / 2)
	//		numclusters += 1;
	//}
	//std::cout << "Number of Cluster After = " << numclusters << std::endl;

	for (int i = 0; i < numvertices; i++)
	{
		CVec3f tmpcol((float)(i/upboundnum) / (float)10000* 2.0f * M_PI, 1, 1);
		m_colors[i] = tmpcol.hsv();
	}



}
